# 排序算法 (sorting-algorithm)

## 术语解释

### 1. 时间复杂度 (Time Complexity)
描述算法执行时间随输入规模增长的变化趋势。用大O表示法表示：
- **O(1)** - 常数时间：无论数据量多大，执行时间都固定
- **O(log n)** - 对数时间：如二分查找
- **O(n)** - 线性时间：遍历一次数组
- **O(n log n)** - 线性对数时间：如快速排序、归并排序
- **O(n²)** - 平方时间：如冒泡排序、选择排序、插入排序
- **O(2ⁿ)** - 指数时间：递归计算斐波那契数列（未优化）

### 2. 空间复杂度 (Space Complexity)
描述算法执行过程中所需的额外内存空间：
- **O(1)** - 原地算法：只需要常数级别的额外空间
- **O(n)** - 需要与输入规模成正比的额外空间

### 3. 稳定性 (Stability)
排序算法的稳定性指：**相等元素在排序后是否保持原有的相对顺序**
- **稳定排序**：相等元素的相对位置不变（如冒泡、插入、归并排序）
- **不稳定排序**：相等元素的相对位置可能改变（如选择、快速、堆排序）

**示例**：
```
原数组: [3a, 2, 3b, 1]  (3a和3b值相等但标记不同)
稳定排序后: [1, 2, 3a, 3b]  ✓ 保持了3a在3b前面
不稳定排序后: [1, 2, 3b, 3a]  ✗ 3a和3b的顺序可能颠倒
```

### 4. 原地排序 (In-Place Sorting)
算法在排序过程中不需要额外的存储空间（或只需要常数级别O(1)的额外空间），直接在原数组上进行操作。

### 5. 比较排序 vs 非比较排序
- **比较排序**：通过比较元素大小来排序（如快速排序、归并排序），理论下界为 O(n log n)
- **非比较排序**：不通过比较，利用元素的特殊性质排序（如计数排序、桶排序、基数排序），可以突破 O(n log n) 的下界

### 6. 最好/平均/最坏情况
- **最好情况**：输入数据最理想的情况（如已排序的数组）
- **平均情况**：输入数据随机分布的平均表现
- **最坏情况**：输入数据最不理想的情况（如逆序数组）

### 7. 自适应性 (Adaptive)
算法能否利用输入数据的已有顺序来提高效率。自适应算法在处理部分有序的数据时性能更好。

## **在线工具**:
- [VisuAlgo 可视化](https://visualgo.net/zh/sorting)

## **技巧**
使用**异或运算**可以不申请额外空间进行元素交换，详见`utils.py/swap_with_bit()`
> 使用异或运算时需要注意交换两者的地址**不可以相同**

## **使用示例**:
```python
from sorting-algorithm.selection_sort import selection_sort

arr = [64, 25, 12, 22, 11]
sorted_arr = selection_sort(arr)
print(sorted_arr)  # [11, 12, 22, 25, 64]
```

## 选择排序 (Selection Sort)

**文件**: `sorting-algorithm/selection_sort.py`

<table>
<tr>
<td colspan="2">

**算法描述**: 
选择排序是一种简单直观的排序算法。它的基本思想是：首先在未排序序列中找到最小（大）元素,存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

</td>
</tr>

<tr>
<td width="80%">

**算法图示**:

```
初始数组: [64, 25, 12, 22, 11]

第1轮: 找到最小值 11，与位置0交换
  [64, 25, 12, 22, 11]
   ↓               ↓
  [11, 25, 12, 22, 64]
   ✓  (已排序)

第2轮: 在剩余元素中找到最小值 12，与位置1交换
  [11, 25, 12, 22, 64]
       ↓   ↓
  [11, 12, 25, 22, 64]
   ✓   ✓  (已排序)

第3轮: 在剩余元素中找到最小值 22，与位置2交换
  [11, 12, 25, 22, 64]
           ↓   ↓
  [11, 12, 22, 25, 64]
   ✓   ✓   ✓  (已排序)

第4轮: 在剩余元素中找到最小值 25，位置不变
  [11, 12, 22, 25, 64]
               ✓  (已排序)

完成: [11, 12, 22, 25, 64]
      ✓   ✓   ✓   ✓   ✓  (全部已排序)
```

</td>
<td width="20%">

**动画演示**: 

![Selection Sort Animation](https://upload.wikimedia.org/wikipedia/commons/9/94/Selection-Sort-Animation.gif)

*动画来源: 维基百科*

</td>
</tr>
</table>


**复杂度分析**:
- ⏱️ 时间复杂度: O(n²)
  - 最好情况: O(n²)
  - 平均情况: O(n²)
  - 最坏情况: O(n²)
- 💾 空间复杂度: O(1)
- 稳定性: 不稳定

**特点**:
- ✅ 实现简单，易于理解
- ✅ 原地排序，空间复杂度低
- ❌ 时间复杂度较高，不适合大数据集
- ❌ 不稳定排序

---

## 冒泡排序 (Bubble Sort)

**文件**: `sorting-algorithm/bubble_sort.py`

<table>
<tr>
<td colspan="2">

**算法描述**: 
冒泡排序是一种简单的排序算法。它的基本思想是：通过重复遍历待排序的数列，比较相邻元素并交换顺序不正确的元素，使得较大的元素逐渐"浮"到数列的顶端。每一轮遍历都会将当前未排序部分的最大元素移动到正确的位置。

</td>
</tr>

<tr>
<td width="80%">

**算法图示**:

```
初始数组: [64, 25, 12, 22, 11]

第1轮: 最大值64冒泡到末尾
  [64, 25, 12, 22, 11]
  比较: 64>25 → 交换
  [25, 64, 12, 22, 11]
  比较: 64>12 → 交换
  [25, 12, 64, 22, 11]
  比较: 64>22 → 交换
  [25, 12, 22, 64, 11]
  比较: 64>11 → 交换
  [25, 12, 22, 11, 64] ✓

第2轮: 最大值25冒泡到倒数第二位
  [25, 12, 22, 11, 64]
  [12, 25, 22, 11, 64]
  [12, 22, 25, 11, 64]
  [12, 22, 11, 25, 64] ✓✓

第3轮: 最大值22冒泡到倒数第三位
  [12, 22, 11, 25, 64]
  [12, 11, 22, 25, 64] ✓✓✓

第4轮: 最大值12冒泡到倒数第四位
  [11, 12, 22, 25, 64] ✓✓✓✓

完成: [11, 12, 22, 25, 64]
      ✓   ✓   ✓   ✓   ✓  (全部已排序)
```

</td>
<td width="20%">

**动画演示**: 

![Bubble Sort Animation](https://upload.wikimedia.org/wikipedia/commons/thumb/0/0c/Bubble_sort_animation_deutsch.gif/640px-Bubble_sort_animation_deutsch.gif)

*动画来源: 维基百科*

</td>
</tr>
</table>


**复杂度分析**:
- ⏱️ 时间复杂度: O(n²)
  - 最好情况: O(n) - 数组已排序时，添加优化标志可达到
  - 平均情况: O(n²)
  - 最坏情况: O(n²) - 数组逆序时
- 💾 空间复杂度: O(1)
- 稳定性: 稳定

**特点**:
- ✅ 实现简单，易于理解
- ✅ 原地排序，空间复杂度低
- ✅ 稳定排序，相等元素相对位置不变
- ✅ 自适应性：可以通过优化提前终止
- ❌ 时间复杂度较高，不适合大数据集
- ❌ 交换次数多，效率较低

**优化技巧**:
1. 当某次循环时**没有交换元素**，表明**排序已完成**，可**提前跳出排序循环**


---

## 插入排序 (Insertion Sort)

**文件**: `sorting-algorithm/insertion_sort.py`

<table>
<tr>
<td colspan="2">

**算法描述**: 
插入排序是一种构建有序序列的算法。它通过维护一个已排序序列，将未排序的元素逐个插入其中合适的位置，直到所有元素均被插入完成。对于小规模和部分有序的数据表现出色。

</td>
</tr>

<tr>
<td width="80%">

**算法图示**:

```
初始数组: [64, 25, 12, 22, 11]

已排序 | 未排序
[64] | [25, 12, 22, 11]

第1轮: 将 25 插入到已排序部分
  [64, 25, 12, 22, 11]
  25<64 → 后移 64
  [64, 64, 12, 22, 11]
  插入 25 → [25, 64, 12, 22, 11]

第2轮: 将 12 插入到已排序部分
  [25, 64, 12, 22, 11]
  12<64 → 后移 64
  [25, 64, 64, 22, 11]
  12<25 → 后移 25
  [25, 25, 64, 22, 11]
  插入 12 → [12, 25, 64, 22, 11]

第3轮: 将 22 插入到已排序部分
  [12, 25, 64, 22, 11]
  22<64 → 后移 64
  [12, 25, 64, 64, 11]
  22>25 → 插入位置在 25 之后
  插入 22 → [12, 22, 25, 64, 11]

第4轮: 将 11 插入到已排序部分
  [12, 22, 25, 64, 11]
  11<64 → 后移 64
  11<25 → 后移 25
  11<22 → 后移 22
  11<12 → 后移 12
  插入 11 → [11, 12, 22, 25, 64]

结果: [11, 12, 22, 25, 64]

```

</td>
<td width="20%">

**动画演示**: 

![Insertion Sort Animation](https://upload.wikimedia.org/wikipedia/commons/thumb/e/ea/Insertion_sort_001.PNG/640px-Insertion_sort_001.PNG)

*图片来源: 维基百科*

</td>
</tr>
</table>


**复杂度分析**:
- ⏱️ 时间复杂度: O(n²)
  - 最好情况: O(n) - 输入已近乎有序
  - 平均情况: O(n²)
  - 最坏情况: O(n²) - 输入完全逆序
- 💾 空间复杂度: O(1)
- 稳定性: 稳定

**特点**:
- ✅ 实现简单，逻辑直观
- ✅ 原地排序，额外空间需求低
- ✅ 稳定排序，适合有重复键的场景
- ✅ 对部分有序、小规模数据效率高
- ❌ 在大规模、完全无序数据上效率较低
- ❌ 每次插入可能涉及大量元素移动

**常见优化**:
- 使用二分查找定位插入位置，减少比较次数（时间仍为 O(n²)，但常数项更小）
- 与分块、希尔排序等结合，处理更大规模数据

---

## 归并排序 (Merge Sort)

**文件**: `sorting_algorithm/merge_sort.py`

<table>
<tr>
<td colspan="2">

**算法描述**:
归并排序采用分治思想：递归地将数组拆分为左右两个子数组，分别排序后再将两个有序子数组合并。每次合并都保持结果有序，因此整体能够在 O(n log n) 的时间复杂度内完成排序。

</td>
</tr>

<tr>
<td width="80%">

**算法图示**:

```
初始数组: [38, 27, 43, 3, 9, 82, 10]

拆分阶段:
[38, 27, 43, 3, 9, 82, 10]
├─ 左: [38, 27, 43]
│   ├─ [38]
│   └─ [27, 43] → 合并 → [27, 43]
│   合并: [38] + [27, 43] → [27, 38, 43]
└─ 右: [3, 9, 82, 10]
    ├─ [3, 9]
    │   ├─ [3]
    │   └─ [9]
    │   合并 → [3, 9]
    └─ [82, 10]
        ├─ [82]
        └─ [10]
        合并 → [10, 82]
    合并: [3, 9] + [10, 82] → [3, 9, 10, 82]

最终合并:
[27, 38, 43] + [3, 9, 10, 82]
→ [3, 9, 10, 27, 38, 43, 82]
```

</td>
<td width="20%">

**动画演示**:

![Merge Sort Animation](https://upload.wikimedia.org/wikipedia/commons/thumb/c/c7/MergeSort.jpg/640px-MergeSort.jpg)

*动画来源: 维基百科*

</td>
</tr>
</table>


**复杂度分析**:
- ⏱️ 时间复杂度: O(n log n)
  - 最好情况: O(n log n)
  - 平均情况: O(n log n)
  - 最坏情况: O(n log n)
- 💾 空间复杂度: O(n)（需要额外数组存放合并结果）
- 稳定性: 稳定

**特点**:
- ✅ 时间复杂度稳定为 O(n log n)，适合大规模数据
- ✅ 稳定排序，适用于需要保持相对顺序的场景
- ✅ 分治结构天然适合并行化实现
- ❌ 需要额外 O(n) 空间，原地性较差
- ❌ 合并阶段涉及大量元素复制，常数项较高

**常见优化**:
- 小规模子数组使用插入排序替代递归调用，减少递归深度
- 通过原地合并或借助环形缓冲区降低额外空间开销
- 自顶向下递归之外，还可以实现自底向上的迭代版本

